<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>OHLCV Chart (data_service)</title>
  <style>
    body { margin:0; padding:0; background:#111; color:#eee; font-family: system-ui, -apple-system, "Segoe UI", sans-serif; }
    #chart { width:100vw; height:100vh; }
    #chart-info {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 10;
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.9);
      color: #000000;
      font-size: 12px;
      border-radius: 6px;
      letter-spacing: 0.2px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@5.0.9/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
  <div id="chart"></div>
  <div id="chart-info">Loading...</div>
  <script>
    const container = document.getElementById("chart");
    const chartInfo = document.getElementById("chart-info");
    let baseInfoText = "Loading...";

    const chart = LightweightCharts.createChart(container, {
      layout: { background: { color: "#ffffff" }, textColor: "#000000" },
      // grid: { vertLines: { color: "#2b2b43" }, horzLines: { color: "#2b2b43" } },
      timeScale: { timeVisible: true, secondsVisible: true },
      crosshair: {
        mode: LightweightCharts.CrosshairMode.Magnet,
      },
    });

    const candleSeries = chart.addSeries(
      LightweightCharts.CandlestickSeries,
      {
        upColor: "#26a69a",
        downColor: "#ef5350",
        borderUpColor: "#26a69a",
        borderDownColor: "#ef5350",
        wickUpColor: "#26a69a",
        wickDownColor: "#ef5350",
        lastValueVisible: false, // Hide default price label
        priceLineVisible: false, // Hide default price line
      }
    );

    // Volume histogram under candles.
    const volumeSeries = chart.addSeries(
      LightweightCharts.HistogramSeries,
      {
        color: "#90caf9",
        priceFormat: { type: "volume" },
        priceScaleId: "",
      }
    );
    volumeSeries.priceScale().applyOptions({
      scaleMargins: { top: 0.8, bottom: 0 },
    });

    // Line series for trade entry/close price markers (circles)
    const entryMarkerSeries = chart.addSeries(
      LightweightCharts.LineSeries,
      {
        color: "#0b33e8",
        lineVisible: false,
        pointMarkersVisible: true,
        lastValueVisible: false,
        priceLineVisible: false,
        crosshairMarkerVisible: true,
      }
    );
    let entryMarkerData = [];
    const entryPriceKeys = new Set(); // De-dup entry price markers.

    const closeMarkerSeries = chart.addSeries(
      LightweightCharts.LineSeries,
      {
        color: "#9d0bec",
        lineVisible: false,
        pointMarkersVisible: true,
        lastValueVisible: false,
        priceLineVisible: false,
        crosshairMarkerVisible: true,
      }
    );
    let closeMarkerData = [];
    const closePriceKeys = new Set(); // De-dup close price markers.

    // Map to store plot series (title -> series)
    const plotSeriesMap = new Map();
    // Track all plot series for cleanup even if titles collide.
    const plotSeriesList = [];

    // Array to store markers
    const markers = [];
    const markerKeys = new Set(); // Track existing markers to prevent duplicates
    let seriesMarkers = null;

    // Separate arrays for plotchar markers
    const plotcharMarkers = [];
    const plotcharMarkerKeys = new Set();
    let plotcharSeriesMarkers = null;

    let firstBarTime = null; // Store first bar time to filter out markers before history
    let timeframeInterval = 60; // Timeframe interval in seconds (will be calculated from OHLCV data)
    let lastBarTime = 0; // Track last bar time to handle out-of-order updates
    let lastOpenPrice = { time: 0, value: 0 };
    let initialLoadInProgress = false;
    let initialLoadDone = false; // Prevent duplicate initial loads.

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Load trade history from server
    async function loadTradeHistory() {
      if (!runnerConnected) return;
      try {
        // Clear markers before reloading history.
        markers.length = 0;
        markerKeys.clear();
        entryMarkerData.length = 0;
        closeMarkerData.length = 0;
        entryPriceKeys.clear();
        closePriceKeys.clear(); // Reset price marker de-dupe keys.

        const resp = await fetch("/api/trades");
        const trades = await resp.json();
        // console.log(trades);
        // console.log(`Loaded ${trades.length} trade events from server`);

        trades.forEach(msg => {
          // Skip markers before first bar
          if (firstBarTime !== null && msg.time < firstBarTime) {
            return;
          }

          if (msg.type === "trade_entry") {
            const markerKey = `entry_${msg.time}_${msg.id}`;
            if (!markerKeys.has(markerKey)) {
              markers.push({
                time: msg.time,
                position: "belowBar",
                color: "#0b33e8",
                shape: "arrowUp",
                text: msg.comment || "",
                size: 0.5,
              });
              markerKeys.add(markerKey);

              // Add price marker (circle at exact price level)
              if (msg.price != null) {
                const priceKey = `entry_${msg.time}_${msg.id}`;
                if (!entryPriceKeys.has(priceKey)) {
                  entryMarkerData.push({ time: msg.time, value: msg.price });
                  entryPriceKeys.add(priceKey);
                }
              }
            }
          } else if (msg.type === "trade_close") {
            const markerKey = `close_${msg.time}_${msg.id}`;
            if (!markerKeys.has(markerKey)) {
              markers.push({
                time: msg.time,
                position: "aboveBar",
                color: "#9d0bec",
                shape: "arrowDown",
                text: msg.comment || "",
                size: 0.5,
              });
              markerKeys.add(markerKey);

              // Add price marker (circle at exact price level)
              if (msg.price != null) {
                const priceKey = `close_${msg.time}_${msg.id}`;
                if (!closePriceKeys.has(priceKey)) {
                  closeMarkerData.push({ time: msg.time, value: msg.price });
                  closePriceKeys.add(priceKey);
                }
              }
            }
          }
        });

        // Apply markers if any exist
        if (markers.length > 0) {
          seriesMarkers = LightweightCharts.createSeriesMarkers(candleSeries, markers);
          // console.log(`Restored ${markers.length} markers`);
        }

        // Apply price markers (circles at exact price levels)
        if (entryMarkerData.length > 0) {
          entryMarkerSeries.setData(entryMarkerData);
        }
        if (closeMarkerData.length > 0) {
          closeMarkerSeries.setData(closeMarkerData);
        }
      } catch (e) {
        console.error("Failed to load trade history:", e);
      }
    }

    // Load plotchar history from server
    async function loadPlotcharHistory() {
      if (!runnerConnected) return;
      try {
        // Clear plotchar markers before reloading history.
        plotcharMarkers.length = 0;
        plotcharMarkerKeys.clear();

        const resp = await fetch("/api/plotchar");
        const plotchars = await resp.json();

        plotchars.forEach(msg => {
          // Skip markers before first bar
          if (firstBarTime !== null && msg.time < firstBarTime) {
            return;
          }

          const markerKey = `plotchar_${msg.time}_${msg.title}`;
          if (!plotcharMarkerKeys.has(markerKey)) {
            // Map location string to position
            let position = 'belowBar';
            if (msg.location === 'aboveBar') {
              position = 'aboveBar';
            } else if (msg.location === 'absolute') {
              position = 'inBar';
            }

            // Add marker to chart
            plotcharMarkers.push({
              time: msg.time,
              position: position,
              color: msg.color || '#2962FF',
              shape: 'circle',
              text: msg.text || msg.char,
              size: msg.size || 1,
            });
            plotcharMarkerKeys.add(markerKey);
          }
        });

        // Apply plotchar markers if any exist
        if (plotcharMarkers.length > 0) {
          plotcharSeriesMarkers = LightweightCharts.createSeriesMarkers(candleSeries, plotcharMarkers);
        }
      } catch (e) {
        console.error("Failed to load plotchar history:", e);
      }
    }

    // Load plot data from server with retry
    async function loadPlotData() {
      if (!runnerConnected) return;
      for (let i = 0; i < 30; i++) { // Retry up to 30 seconds
        try {
          const resp = await fetch("/api/plot?limit=100000");
          const plots = await resp.json();

          if (Array.isArray(plots) && plots.length > 0) {
            const pendingSeriesData = [];
            plots.forEach(plot => {
              // Convert null/undefined values to NaN
              if (plot.data && Array.isArray(plot.data)) {
                plot.data.forEach(point => {
                  if (point.value == null) {
                    point.value = NaN;
                  }
                });
              }

              const { title, color, linewidth, style, data } = plot;

              // Plot style constants (from plot.py PlotEnum)
              // style_area = 0, style_areabr = 1, style_circles = 2, style_columns = 3,
              // style_cross = 4, style_histogram = 5, style_line = 6, style_linebr = 7,
              // style_stepline = 8, style_stepline_diamond = 9
              const STYLE_CIRCLES = 2;
              const STYLE_CROSS = 4;

              // Determine series options based on style
              const isCrossStyle = (parseInt(style) === STYLE_CROSS || parseInt(style) === STYLE_CIRCLES);
              const seriesOptions = {
                color: color || "#2962FF",
                lastValueVisible: false,
                priceLineVisible: false,
                crosshairMarkerVisible: true,
              };

              // For cross/circles style, show point markers and hide line (like entryMarkerSeries)
              if (isCrossStyle) {
                seriesOptions.lineVisible = false;
                seriesOptions.pointMarkersVisible = true;
                seriesOptions.pointMarkersRadius = 1;
              } else {
                // For line style, set line width
                seriesOptions.lineWidth = linewidth || 2;
              }

              // Create line series for this plot
              const series = chart.addSeries(LightweightCharts.LineSeries, seriesOptions);
              plotSeriesList.push(series);

              // Store series in map
              plotSeriesMap.set(title, series);
              pendingSeriesData.push([series, data]);
            });

            // Set data after all series are created.
            pendingSeriesData.forEach(([series, data]) => {
              if (data && data.length > 0) {
                series.setData(data);
              }
            });

            // console.log(`Loaded ${plots.length} plot series`);
            return; // Success, exit retry loop
          }
        } catch (e) {
          // Ignore and retry
        }
        await sleep(1000);
      }
      // console.log("Plot data not ready (timeout or no plots)");
    }

    // 최초 로드에서만 히스토리 준비될 때까지 재시도
    async function loadInitialWithRetry() {
      if (initialLoadInProgress || initialLoadDone) {
        return;
      }
      initialLoadInProgress = true;
      for (let i = 0; i < 30; i++) { // 최대 30초
        try {
          const resp = await fetch("/api/ohlcv?limit=100000");
          const data = await resp.json();
          if (Array.isArray(data) && data.length > 0) {
            // Store data in array for later updates
            const cleanData = data.filter(d => d && d.time != null && d.open != null && d.high != null && d.low != null && d.close != null);
            if (cleanData.length === 0) {
              await sleep(1000);
              continue;
            }
            candleSeries.setData(cleanData);
            // Volume bars share the same timestamps as candles.
            volumeSeries.setData(cleanData.map(d => ({
              time: d.time,
              value: d.volume,
              color: d.close >= d.open ? "#26a69a" : "#ef5350",
            })));
            chart.timeScale().fitContent();
            const savedRange = sessionStorage.getItem("chartVisibleRange");
            const savedLogicalRange = sessionStorage.getItem("chartVisibleLogicalRange");
            const savedScale = sessionStorage.getItem("chartScaleOptions");
            if (savedScale) {
              try {
                const opts = JSON.parse(savedScale);
                chart.timeScale().applyOptions(opts);
              } catch {}
              sessionStorage.removeItem("chartScaleOptions");
            }
            if (savedLogicalRange) {
              try {
                const range = JSON.parse(savedLogicalRange);
                chart.timeScale().setVisibleLogicalRange(range);
              } catch {}
              sessionStorage.removeItem("chartVisibleLogicalRange");
            } else if (savedRange) {
              try {
                const range = JSON.parse(savedRange);
                chart.timeScale().setVisibleRange(range);
              } catch {}
              sessionStorage.removeItem("chartVisibleRange");
            }

            // Store first bar time for marker filtering
            firstBarTime = data[0].time;
            // console.log(`First bar time: ${firstBarTime}`);

            // Calculate timeframe interval from OHLCV data
            if (data.length >= 2) {
              timeframeInterval = data[1].time - data[0].time;
              // console.log(`Timeframe interval: ${timeframeInterval} seconds`);
            }

            // Set initial last price
            if (data.length > 0) {
              lastPrice = data[data.length - 1].close;
              lastOhlcv = data[data.length - 1];
            }

            // Load trade history, plotchar history, and plot data after OHLCV data is loaded
            await loadTradeHistory();
            await loadPlotcharHistory();
            await loadPlotData();
            initialLoadDone = true;
            initialLoadInProgress = false;
            return;
          }
        } catch (e) {
          // ignore
        }
        await sleep(1000);
      }
      console.error("Initial OHLCV not ready (timeout).");
      initialLoadInProgress = false;
    }

    let ws = null;
    let runnerConnected = false;
    function resetChartState(resetCandles = true) {
      // Keep candles when only the runner disconnects.
      initialLoadDone = false;
      initialLoadInProgress = false; // Allow next initial load after reset.
      if (resetCandles) {
        candleSeries.setData([]);
        volumeSeries.setData([]);
      }
      entryMarkerSeries.setData([]);
      closeMarkerSeries.setData([]);
      if (seriesMarkers) {
        seriesMarkers.setMarkers([]);
      }
      if (plotcharSeriesMarkers) {
        plotcharSeriesMarkers.setMarkers([]);
      }
      for (const series of plotSeriesList) {
        chart.removeSeries(series);
      }
      plotSeriesList.length = 0;
      plotSeriesMap.clear();
      markers.length = 0;
      markerKeys.clear();
      plotcharMarkers.length = 0;
      plotcharMarkerKeys.clear();
      entryMarkerData.length = 0;
      closeMarkerData.length = 0;
      entryPriceKeys.clear();
      closePriceKeys.clear(); // Clear price marker de-dupe keys.
      seriesMarkers = null;
      plotcharSeriesMarkers = null;
      firstBarTime = null;
      timeframeInterval = 60;
      lastBarTime = 0;
      lastOpenPrice = { time: 0, value: 0 };
      lastPrice = 0;
      if (currentPriceLine && candleSeries.removePriceLine) {
        candleSeries.removePriceLine(currentPriceLine);
      }
      currentPriceLine = null;
    }
    function connectWS() {
      ws = new WebSocket(`ws://${location.host}/ws`);

      ws.onopen = () => {
        console.log("ws connected");
        loadInitialWithRetry();
      };

      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.type === "script_modified") {
            // Script change should reset and reload full chart state.
            resetChartState(false);
            loadInitialWithRetry();
          } else if (msg.type === "runner_disconnected") {
            // Runner disconnect should not wipe candle history.
            runnerConnected = false;
            resetChartState(false);
          } else if (msg.type === "runner_connected") {
            // Runner connected; allow initial load.
            runnerConnected = true;
            loadInitialWithRetry();
          } else if (msg.type === "bar") {
            // Check if this is an out-of-order update (confirmed bar after new bar)
            if (msg.data.time < lastBarTime) {
              // console.log(`Skipping out-of-order bar update: ${msg.data.time} < ${lastBarTime}`);
              return;
            }

            // Update open price if necessary
            if (msg.data.time === lastOpenPrice.time && lastOpenPrice.value > 0 && msg.data.open != parseFloat(lastOpenPrice.value.toFixed(2))) {
                // console.log(`Updating open price: ${msg.data.open} --> ${lastOpenPrice.value.toFixed(2)}`);
                msg.data.open = lastOpenPrice.value;
            }

            candleSeries.update(msg.data);
            volumeSeries.update({
              time: msg.data.time,
              value: msg.data.volume,
              color: msg.data.close >= msg.data.open ? "#26a69a" : "#ef5350",
            });
            lastBarTime = msg.data.time;
            lastOhlcv = msg.data;

            // Update last price for the price line
            if (msg.data && msg.data.close !== undefined) {
              lastPrice = msg.data.close;
            }
          } else if (msg.type === "last_bar_open_fix") {
            lastOpenPrice.time = msg.data.time;
            lastOpenPrice.value = msg.data.open;

            // Fix entry marker if price differs from open
            const entryIndex = entryMarkerData.findIndex(m => m.time === msg.data.time);
            if (entryIndex !== -1) {
              const priceDiff = Math.abs(entryMarkerData[entryIndex].value - msg.data.open);
              if (priceDiff > 0.01) {
                console.log(`Fix entry marker: ${entryMarkerData[entryIndex].value} --> ${msg.data.open}`);
                entryMarkerData[entryIndex].value = msg.data.open;
                entryMarkerSeries.setData(entryMarkerData);
              }
            }

            // Fix close marker if price differs from open
            const closeIndex = closeMarkerData.findIndex(m => m.time === msg.data.time);
            if (closeIndex !== -1) {
              const priceDiff = Math.abs(closeMarkerData[closeIndex].value - msg.data.open);
              if (priceDiff > 0.01) {
                console.log(`Fix close marker: ${closeMarkerData[closeIndex].value} --> ${msg.data.open}`);
                closeMarkerData[closeIndex].value = msg.data.open;
                closeMarkerSeries.setData(closeMarkerData);
              }
            }
          } else if (msg.type === "trade_entry") {
            // Skip markers before first bar
            if (firstBarTime !== null && msg.time < firstBarTime) {
              return;
            }

            // Create unique key for this marker
            const markerKey = `entry_${msg.time}_${msg.id}`;

            // Skip if marker already exists
            if (markerKeys.has(markerKey)) {
              return;
            }

            // Add entry marker
            markers.push({
              time: msg.time,
              position: "belowBar",
              color: "#0b33e8",
              shape: "arrowUp",
              text: msg.comment || "",
              size: 0.5,
            });
            markerKeys.add(markerKey);

            // Add price marker (circle at exact price level)
            if (msg.price != null && Number.isFinite(Number(msg.price)) && Number.isFinite(Number(msg.time))) {
              const priceKey = `entry_${msg.time}_${msg.id}`;
              if (!entryPriceKeys.has(priceKey)) {
                // console.log("Adding price marker:", msg.price);
                entryMarkerData.push({ time: Number(msg.time), value: Number(msg.price) });
                entryPriceKeys.add(priceKey);
                entryMarkerData = entryMarkerData.filter(m => Number.isFinite(Number(m.time)) && Number.isFinite(Number(m.value)));
                entryMarkerSeries.setData(entryMarkerData);
              }
            }

            // Update markers using createSeriesMarkers
            if (seriesMarkers) {
              seriesMarkers.setMarkers([]);
            }
            seriesMarkers = LightweightCharts.createSeriesMarkers(candleSeries, markers);
            // console.log("Entry marker added:", msg);
          } else if (msg.type === "trade_close") {
            // Skip markers before first bar
            if (firstBarTime !== null && msg.time < firstBarTime) {
              return;
            }

            // Create unique key for this marker
            const markerKey = `close_${msg.time}_${msg.id}`;

            // Skip if marker already exists
            if (markerKeys.has(markerKey)) {
              return;
            }

            // Add close marker
            markers.push({
              time: msg.time,
              position: "aboveBar",
              color: "#9d0bec",
              shape: "arrowDown",
              text: msg.comment || "",
              size: 0.5,
            });
            markerKeys.add(markerKey);

            // Add price marker (circle at exact price level)
            if (msg.price != null && Number.isFinite(Number(msg.price)) && Number.isFinite(Number(msg.time))) {
              const priceKey = `close_${msg.time}_${msg.id}`;
              if (!closePriceKeys.has(priceKey)) {
                closeMarkerData.push({ time: Number(msg.time), value: Number(msg.price) });
                closePriceKeys.add(priceKey);
                closeMarkerData = closeMarkerData.filter(m => Number.isFinite(Number(m.time)) && Number.isFinite(Number(m.value)));
                closeMarkerSeries.setData(closeMarkerData);
              }
            }

            // Update markers using createSeriesMarkers
            if (seriesMarkers) {
             seriesMarkers.setMarkers([]);
            }
            seriesMarkers = LightweightCharts.createSeriesMarkers(candleSeries, markers);
            // console.log("Close marker added:", msg);
          } else if (msg.type === "plotchar") {
            // Skip markers before first bar
            if (firstBarTime !== null && msg.time < firstBarTime) {
              return;
            }

            // Create unique key for this marker
            const markerKey = `plotchar_${msg.time}_${msg.title}`;

            // Skip if marker already exists
            if (plotcharMarkerKeys.has(markerKey)) {
              return;
            }

            // Map location string to position
            let position = 'belowBar';
            if (msg.location === 'aboveBar') {
              position = 'aboveBar';
            } else if (msg.location === 'absolute') {
              position = 'inBar';
            }

            // Add plotchar marker
            plotcharMarkers.push({
              time: msg.time,
              position: position,
              color: msg.color || '#2962FF',
              shape: 'circle',
              text: msg.text || msg.char,
              size: msg.size || 1,
            });
            plotcharMarkerKeys.add(markerKey);

            // Update plotchar markers using createSeriesMarkers
            if (plotcharSeriesMarkers) {
              plotcharSeriesMarkers.setMarkers([]);
            }
            plotcharSeriesMarkers = LightweightCharts.createSeriesMarkers(candleSeries, plotcharMarkers);
          } else if (msg.type === "plot_data") {
            // Update plot series with new data point
            const { title, time, value } = msg;

            // Get or create series for this title
            let series = plotSeriesMap.get(title);
            if (series) {
              // Convert null to NaN for chart gaps
              const plotValue = (value == null || isNaN(value)) ? NaN : value;
              // console.log(`Update plot ${title}:`, { time, value: plotValue });
              series.update({ time, value: plotValue });
            }
          }
        } catch (e) {
          console.error("ws parse error", e);
        }
      };

      ws.onclose = () => {
        // Socket close resets overlays but preserves candles.
        resetChartState(false);
        ws = null;
        setTimeout(connectWS, 1000);
      };
      ws.onerror = () => {
        // Socket errors reset overlays but keep candles intact.
        resetChartState(false);
        try { ws.close(); } catch {}
      };
    }

    connectWS();

    // Load chart meta info (symbol/timeframe/exchange).
    fetch("/api/info")
      .then(r => r.json())
      .then(info => {
        const exchange = (info.exchange || "Unknown").toUpperCase();
        const symbol = info.symbol || "Unknown";
        const timeframe = info.timeframe || "Unknown";
        baseInfoText = `<strong>${symbol} | ${timeframe} | ${exchange}</strong>`;
        chartInfo.innerHTML = baseInfoText;
      })
      .catch(() => {
        baseInfoText = "<strong>Unknown | Unknown | Unknown</strong>";
        chartInfo.innerHTML = baseInfoText;
      });

    function formatNumber(value, decimals) {
      if (value == null || Number.isNaN(value)) return "-";
      return Number(value).toLocaleString(undefined, {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals,
      });
    }

    // Show OHLCV on crosshair.
    chart.subscribeCrosshairMove(param => {
      if (!param || !param.time) {
        if (!lastOhlcv) {
          chartInfo.innerHTML = baseInfoText;
          return;
        }
        const ohlcvText = `O <span style="color:#d32f2f">${formatNumber(lastOhlcv.open, 1)}</span>` +
          ` H <span style="color:#d32f2f">${formatNumber(lastOhlcv.high, 1)}</span>` +
          ` L <span style="color:#d32f2f">${formatNumber(lastOhlcv.low, 1)}</span>` +
          ` C <span style="color:#d32f2f">${formatNumber(lastOhlcv.close, 1)}</span>` +
          ` Vol <span style="color:#d32f2f">${formatNumber(lastOhlcv.volume, 2)}</span>`;
        chartInfo.innerHTML = `${baseInfoText} | ${ohlcvText}`;
        return;
      }
      const bar = param.seriesData.get(candleSeries);
      const volBar = param.seriesData.get(volumeSeries);
      if (!bar) {
        chartInfo.innerHTML = baseInfoText;
        return;
      }
      const volumeValue = volBar ? volBar.value : (lastOhlcv ? lastOhlcv.volume : null);
      const ohlcvText = `O <span style="color:#d32f2f">${formatNumber(bar.open, 1)}</span>` +
        ` H <span style="color:#d32f2f">${formatNumber(bar.high, 1)}</span>` +
        ` L <span style="color:#d32f2f">${formatNumber(bar.low, 1)}</span>` +
        ` C <span style="color:#d32f2f">${formatNumber(bar.close, 1)}</span>` +
        ` Vol <span style="color:#d32f2f">${formatNumber(volumeValue, 2)}</span>`;
      chartInfo.innerHTML = `${baseInfoText} | ${ohlcvText}`;
    });

    // keepalive
    setInterval(() => {
      if (ws && ws.readyState === WebSocket.OPEN) ws.send("ping");
    }, 15000);

    // Reload once if average frame interval indicates severe jank.
    let jankFrames = [];
    let jankReloaded = false;
    let lastFrameTs = null;
    function monitorJank(ts) {
      if (lastFrameTs != null) {
        const delta = ts - lastFrameTs;
        jankFrames.push(delta);
        if (jankFrames.length > 60) {
          jankFrames.shift();
        }
        if (!jankReloaded && jankFrames.length === 60) {
          const avg = jankFrames.reduce((a, b) => a + b, 0) / jankFrames.length;
          if (avg >= 60) {
            jankReloaded = true;
            try {
              const range = chart.timeScale().getVisibleRange();
              if (range) {
                sessionStorage.setItem("chartVisibleRange", JSON.stringify(range));
              }
              const logicalRange = chart.timeScale().getVisibleLogicalRange();
              if (logicalRange) {
                sessionStorage.setItem("chartVisibleLogicalRange", JSON.stringify(logicalRange));
              }
              const scaleOptions = chart.timeScale().options();
              sessionStorage.setItem("chartScaleOptions", JSON.stringify({
                rightOffset: scaleOptions.rightOffset,
                barSpacing: scaleOptions.barSpacing,
                rightBarStaysOnScroll: scaleOptions.rightBarStaysOnScroll,
              }));
            } catch {}
            location.reload();
            return;
          }
        }
      }
      lastFrameTs = ts;
      requestAnimationFrame(monitorJank);
    }
    requestAnimationFrame(monitorJank);

    // Resize chart when the window size changes.
    window.addEventListener("resize", () => {
      chart.applyOptions({
        width: container.clientWidth,
        height: container.clientHeight,
      });
    });

    // Current price line with next candle timer
    let currentPriceLine = null;
    let lastPrice = 0;
    let lastOhlcv = null;

    function updatePriceLineWithTimer() {
      if (timeframeInterval === 0 || lastPrice === 0) return;

      const now = Date.now();
      const currentTime = Math.floor(now / 1000);

      // Calculate next candle start time
      const nextCandleTime = Math.ceil(currentTime / timeframeInterval) * timeframeInterval;
      const remainingSeconds = nextCandleTime - currentTime;

      const minutes = Math.floor(remainingSeconds / 60);
      const seconds = remainingSeconds % 60;
      const timeText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

      if (currentPriceLine) {
        currentPriceLine.applyOptions({
          price: lastPrice,
          title: `${timeText}`,
        });
      } else {
        currentPriceLine = candleSeries.createPriceLine({
          price: lastPrice,
          color: '#2196F3',
          lineWidth: 0,
          lineStyle: 2, // dashed
          axisLabelVisible: true,
          title: `${lastPrice.toFixed(2)} | ${timeText}`,
        });
      }
    }

    // Update price line every second
    setInterval(updatePriceLineWithTimer, 1000);
    updatePriceLineWithTimer(); // Initial call
  </script>
</body>
</html>
